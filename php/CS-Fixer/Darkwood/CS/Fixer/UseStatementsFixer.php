<?php

namespace Darkwood\CS\Fixer;

use Symfony\CS\FixerInterface;

class UseStatementsFixer implements FixerInterface
{
    public function fix(\SplFileInfo $file, $content)
    {
        // some fixtures are auto-generated by Symfony and may contain unused use statements
        if (false !== strpos($file, '/Fixtures/')) {
            return $content;
        }

        $useTree = array();

        // [Structure] remove unused use statements
        if (preg_match_all('/^use (?P<class>[^\s;]+)(?:\s+as\s+(?P<alias>.*))?;/m', $content, $matches, PREG_OFFSET_CAPTURE)) {
            foreach ($matches[0] as $mi => $match) {
                $use = &$useTree;
                $class = $matches['class'][$mi][0];
                $parts = explode('\\', $class);
                foreach ($parts as $i => $part) {
                    $part = trim($part);

                    if (!isset($use[$part])) {
                        $use[$part] = array(
                            'parts' => array(),
                            'final' => false,
                            'alias' => null,
                        );
                    }

                    $final = $use[$part]['final'] || (count($parts) - 1 == $i);
                    if (is_null($use[$part]['alias'])) {
                        $alias = $final && isset($matches['alias'][$mi][0]) ? $matches['alias'][$mi][0] : null;
                    }

                    $use[$part]['final'] = $final;
                    $use[$part]['alias'] = $alias;

                    $use = &$use[$part]['parts'];
                }

                $content = str_replace($match[0]."\n", '', $content);
            }

            $uses = $this->useParse($useTree);

            $offset = $matches[0][0][1];
            $content = substr($content, 0, $offset).implode("\n", $uses)."\n".substr($content, $offset);
        }

        return $content;
    }

    private function useParse($useTree, $parts = '')
    {
        $uses = array();

        ksort($useTree);
        foreach ($useTree as $use => $tree) {
            $use = $parts.$use;
            if ($tree['final']) {
                $uses[] = 'use ' . $use . (is_null($tree['alias']) ? '' : ' as '.$tree['alias']).';';
            }
            $useChildren = $this->useParse($tree['parts'], $use.'\\');
            foreach ($useChildren as $useChild) {
                $uses[] = $useChild;
            }
        }

        return $uses;
    }

    public function getLevel()
    {
        return FixerInterface::ALL_LEVEL;
    }

    public function getPriority()
    {
        // should be run before the ExtraEmptyLinesFixer and after UnusedUseStatementsFixer
        return 4;
    }

    public function supports(\SplFileInfo $file)
    {
        return 'php' == pathinfo($file->getFilename(), PATHINFO_EXTENSION);
    }

    public function getName()
    {
        return 'use';
    }

    public function getDescription()
    {
        return 'Use statements must be ordered and written after namespace.';
    }
}
